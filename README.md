# RetailCRM Integration Service

### RetailCRM Integration Service — сервис для интеграции и взаимодействия с CRM-системой.
Приложение поддерживает запуск через Docker Compose и Docker.


### Переменные окружения
#### Перед запуском необходимо создать файл `.env` в корне проекта и **обязательно указать собственные значения переменных окружения**. Данные, приведённые в `.env.example`, являются **примером** и взяты из документации **RetailCRM**.

Для создания файла `.env` необходимо выполнить команду:
```bash
cp .env.example .env
```

## Запуск через Docker Compose
### Сборка образа
```bash
make build
```
### Запуск контейнера
```bash
make run
```
### Остановка контейнера
```bash
make stop
```
### Полная остановка и удаление контейнера
```bash
make down
```
### Просмотр логов
```bash
make log
```

## Запуск через Docker
### Сборка Docker-образа
```bash
make docker-build
```
### Запуск контейнера
```bash
make docker-run
```
### Просмотр логов контейнера
```bash
make docker-logs
```
### Остановка контейнера
```bash
make docker-stop
```
### Удаление контейнера
```bash
make docker-rm
```

## API Documentation
После запуска приложения API-документация доступна по следующим адресам:
- Swagger UI:  
  http://127.0.0.1:8000/api/docs
- ReDoc:  
  http://127.0.0.1:8000/api/redoc

### Linting
```bash
make lint
```

## Основные моменты реализации:

**1. Архитектурное разделение:**
   - Логика разделена на слои. Это делает код модульным: технические детали CRM не смешиваются с бизнес-логикой и маршрутами FastAPI.
   - API: Принимают внешние запросы, вызывают нужные сервисы и возвращают ответ.
   - Сервисы: Содержат бизнес-логику приложения, координируют работу с данными и клиентом CRM.
   - Клиент: Инкапсулирует технические детали взаимодействия с RetailCRM (авторизация, формирование URL).
   - Схемы: Описывают структуру данных, обеспечивая автоматическую валидацию и преобразование типов на всех этапах.

**2. Централизованная работа с HTTP:**
   - Вся работа с HTTP вынесена в `RetailCRMApiClient`. Это позволяет в одном месте управлять таймаутами, логированием и заголовками.
   - Автоматическая авторизация: `apiKey` добавляется к параметрам внутри клиента, что упрощает вызовы в сервисах.

**3. Автоматизация упаковки параметров:**
   - Реализована логика, которая сама разделяет параметры на системные `(page, limit)` и фильтры `(filter[...])`. Это избавило от ручного формирования словарей в каждом методе.

**4. Валидация и типизация:**
   - Использование Pydantic-схем для всех входящих фильтров и ответов API. Параметры переводятся в JSON-совместимый формат.

**5. Обработка специфики POST-запросов:**
   - Добавлена автоматическая сериализация вложенных структур в JSON-строки для корректной передачи данных.

### Моменты, которые вызвали трудности:
1.Определение ответственности слоев: Одной из задач был выбор слоя для сериализации данных.

Решение: Логику преобразования было решено вынести в Клиент. Это позволило не загромождать Сервисы техническими деталями формата RetailCRM и оставить их код чистым.

2.Проектирование методов: Был выбор — передавать ID (например, id клиента) внутри общего списка фильтров или как отдельный параметр.

Решение: Было решено вынести ID в отдельный обязательный аргумент. Это гарантирует передачу обязательного параметра и дает четкое понимание, по какому именно объекту мы запрашиваем данные.